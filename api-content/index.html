{"posts":[{"title":"Basic Sorting Algorithm","content":"1.初等排序 概述 一般来说数据都是一张具有多个属性的表，所谓的排序就是以按照某种特定的属性为基准，这个特定属性就是排序键。 准则 复杂度 稳定性 所谓的稳定性是指：当有多个键值相等时，排序先后顺序按照输入的先后顺序。 2.插入排序 插入排序问题描述 代码实现 #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const int maxn = 10010; int A[maxn]; void trace(int A[], int n) { for (int i = 0; i &lt; n; i++) { if (i &gt; 0) printf(&quot; &quot;); printf(&quot;%d&quot;, A[i]); } printf(&quot;\\n&quot;); } void insertionSort(int A[], int n) { for (int i = 1; i &lt; n; i++) { int temp = A[i]; int j = i - 1; // j从i往前枚举 while (j &gt;= 0 &amp;&amp; A[j] &gt; temp) { A[j+1] = A[j]; j--; } A[j+1] = temp; trace(A, n); } } int main() { int n; while (scanf(&quot;%d&quot;, &amp;n) != EOF) { for (int i = 0; i &lt; n; i++) { scanf(&quot;%d&quot;, &amp;A[i]); } trace(A, n); insertionSort(A, n); } return 0; } 算法解析 外层循环i从1开始自增，每次循环的A[i]值保存在变量temp中。 内存循环j从前往后枚举，找到比temp大的元素并依次后移，循环结束将temp插入j+1位置。 插入排序不相邻的元素不会直接交换位置，所以插入排序是稳定排序。 插入排序的算法复杂度是O(n^2). 插入排序适用于相对有序的数据 3.冒泡排序 冒泡排序问题描述 代码实现 #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const int maxn = 10010; int A[maxn]; int bubbleSort(int A[], int n) { int count = 0; bool flag = true; for (int i = 0; flag; i++) { flag = false; for (int j = n-1; j &gt;= i+1; j--) { if (A[j] &lt; A[j-1]) { swap(A[j], A[j-1]); flag = true; count++; } } } return count; } int main() { int n; while (scanf(&quot;%d&quot;, &amp;n) != EOF) { for (int i = 0; i &lt; n; i++) { scanf(&quot;%d&quot;, &amp;A[i]); } int res = bubbleSort(A, n); for (int i = 0; i &lt; n; i++) { if (i &gt; 0) printf(&quot; &quot;); printf(&quot;%d&quot;, A[i]); } printf(&quot;\\n&quot;); printf(&quot;%d\\n&quot;, res); } return 0; } 算法解析 外层循环i表示未排序的开头元素，从开头向末尾移动。 内存循环j表示相邻元素之间两两比较。 冒泡排序是稳定的排序算法，但如果把条件判断改为A[j] &lt;= A[j-1]，则此时是不稳定算法。 冒泡排序的算法复杂度是O(n^2). 冒泡排序当中的交换次数又称为反序数或逆序数（线性代数），体现的是数组的错乱程度。 4.选择排序 选择排序问题描述 代码实现 #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const int maxn = 10010; int A[maxn]; int selectSort(int A[], int n) { int count = 0; int temp; for (int i = 0; i &lt; n-1; i++) { int k = i; for (int j = i; j &lt; n; j++) { if (A[j] &lt; A[k]) { k = j; } } temp = A[i]; A[i] = A[k]; A[k] = temp; if (i != k) count++; } return count; } int main() { int n; while (scanf(&quot;%d&quot;, &amp;n) != EOF) { for (int i = 0; i &lt; n; i++) { scanf(&quot;%d&quot;, &amp;A[i]); } int res = selectSort(A, n); for (int i = 0; i &lt; n; i++) { if (i &gt; 0) printf(&quot; &quot;); printf(&quot;%d&quot;, A[i]); } printf(&quot;\\n&quot;); printf(&quot;%d\\n&quot;, res); } return 0; } 算法解析 外层循环i遍历数组。 内层循环j遍历从i开始的未排好序的序列，从这个序列中找出最小值，并交换元素。 冒泡排序从局部入手减少逆序数，选择排序放眼大局逐个选择最小值。 ","link":"https://lesenelir.github.io/post/basic-sorting-algorithm/"}]}