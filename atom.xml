<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lesenelir.github.io</id>
    <title>Lesenelir&apos;s Blog</title>
    <updated>2022-04-02T08:28:20.170Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lesenelir.github.io"/>
    <link rel="self" href="https://lesenelir.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://lesenelir.github.io/images/avatar.png</logo>
    <icon>https://lesenelir.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Lesenelir&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[JavaScript-Asynchronous]]></title>
        <id>https://lesenelir.github.io/post/javascript-asynchronous/</id>
        <link href="https://lesenelir.github.io/post/javascript-asynchronous/">
        </link>
        <updated>2022-03-14T08:20:42.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-异步操作概述">一、异步操作概述</h3>
<h4 id="11-单线程模式">1.1 单线程模式</h4>
<p>单线程模式让JavaScript可能不会出现“堵塞”问题</p>
<p><strong>事件循环机制Event Loop：</strong></p>
<ul>
<li>
<pre><code>  JS引擎一遍遍检查：只要同步任务执行完后，JS引擎就检查挂起来的异步任务能否进入主线程
</code></pre>
</li>
<li>
<pre><code>  这种循环检查机制，就叫事件循环
</code></pre>
</li>
<li>
<pre><code>  Promise回调函数是微任务，是一种特殊的异步任务；正常异步任务是在下一次事件循环执行，微任务是在本次事件循环执行
</code></pre>
</li>
</ul>
<hr>
<h4 id="12-同步任务和异步任务">1.2 同步任务和异步任务</h4>
<p>同步任务：</p>
<ul>
<li>没有被引擎挂起，在主线程排队执行的任务</li>
<li>只有前一个任务执行完毕，才能执行后一个任务</li>
</ul>
<p>异步任务：</p>
<ul>
<li>被引擎挂起，不进入主线程，进入任务队列的任务</li>
<li><strong>异步任务的写法都是采用回调函数方式</strong></li>
<li>异步任务不具有“堵塞”效应</li>
</ul>
<p>举例：</p>
<blockquote>
<p>Ajax 操作可以当作同步任务处理，也可以当作异步任务处理， 由开发者决定。</p>
<p>如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行（会存在等待时延）。</p>
<p>如果是异步任务，主线程在发出 Ajax 请求后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的<strong>回调函数（异步任务）</strong>。</p>
</blockquote>
<blockquote>
<p>Note:</p>
<ol>
<li>
<p>异步任务重新进入主线程是采用回调函数（函数作为参数）的方式</p>
</li>
<li>
<p>回调函数： 函数作为参数；定义了、执行了、但没调用</p>
</li>
</ol>
</blockquote>
<hr>
<h4 id="13-任务队列和事件循环">1.3 任务队列和事件循环</h4>
<p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。</p>
<p>JS运行流程：</p>
<p>主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务通过回调函数的形式重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p>
<ul>
<li>任务队列里存放异步任务</li>
<li>异步任务写法通常都是回调函数</li>
<li>一旦异步任务重新进入主线程，就会执行对应的回调函数</li>
<li>如果一个异步任务没有回调函数，就不会进入任务队列，即不会重新进入主线程（没有回调函数执行指定的操作）</li>
</ul>
<blockquote>
<p>通过编写回调函数的方式实现异步任务，一旦异步任务重新进入主线程，就执行回调函数</p>
</blockquote>
<hr>
<h4 id="14-异步操作的模式">1.4 异步操作的模式</h4>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
</ul>
<hr>
<h4 id="15-异步操作的流程控制">1.5 异步操作的流程控制</h4>
<p>Problem： 多个异步操作，如何确定异步操作执行的顺序，以及如何保证遵守这种顺序</p>
<hr>
<h3 id="二-定时器">二、定时器</h3>
<p><code>setTimeout</code>函数用来指定某个函数或某段代码，在多少毫秒之后执行</p>
<p><code>setInterval</code>指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</p>
<p><strong>定时器运行机制：</strong></p>
<p><code>setTimeout</code>和<code>setInterval</code>的运行机制，是<strong>将指定的代码移出本轮事件循环</strong>，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。</p>
<p><code>setTimeout</code>和<code>setInterval</code>指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。</p>
<hr>
<h3 id="三-promise对象简单介绍">三、Promise对象简单介绍</h3>
<h4 id="31-概述">3.1 概述</h4>
<blockquote>
<p>Promise对象是Js的异步操作解决方案，为异步操作提供统一的接口。</p>
<p>充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口</p>
</blockquote>
<p>Promise是一个对象，也是一个构造函数</p>
<blockquote>
<p>Promise设计思想：所有异步任务返回一个Promise实例，Promise实例有一个.then方法，用来指定下一步的回调函数</p>
</blockquote>
<pre><code class="language-javascript">function f1(resolve, reject) {
  // 异步代码...
}

var p1 = new Promise(f1);
p1.then(f2); // f1执行完才会去执行f2
// 传统写法把f2作为回调函数传入f1，比如写成f1(f2)
</code></pre>
<hr>
<h4 id="32-promise对象状态">3.2 Promise对象状态</h4>
<p>Promise实例有三种状态</p>
<ul>
<li>异步操作未完成 pending</li>
<li>执行异步操作后，异步操作成功 resolved，传回一个值value</li>
<li>执行异步操作后，异步操作失败 rejected，抛出一个错误error</li>
</ul>
<blockquote>
<p>一旦发生状态变化，就凝固，不会有新的状态变化。即，Promise实例状态变化只发生一次。</p>
</blockquote>
<hr>
<h4 id="33-promise构造函数">3.3 Promise构造函数</h4>
<pre><code class="language-javascript">var promise = new Promise(function (resolve, reject) {
  // ...

  if (/* 异步操作成功 */){
    resolve(value);
  } else { /* 异步操作失败 */
    reject(new Error());
  }
});
</code></pre>
<p>Promise构造函数接受一个函数作为参数（该函数称之为构造器函数），构造器函数的参数是resolve和reject，这两个也是函数，并由JavaScript引擎提供。</p>
<p><strong>resolve和reject本身都是一个函数</strong></p>
<blockquote>
<p>resolve，在异步操作成功时调用，将异步操作的结果，作为参数传递出去。</p>
<p>reject，在异步操作失败时调用，将异步操作抛出的错误，作为参数传递出去</p>
</blockquote>
<hr>
<h4 id="34-promiseprototypethen">3.4 Promise.prototype.then()</h4>
<p>Promise 实例的<code>then</code>方法，用来指定添加回调函数</p>
<blockquote>
<p>.then()可以接受两个回调函数参数：</p>
<ol>
<li>一个是异步操作成功的回调函数</li>
<li>一个是异步操作失败的回调函数</li>
</ol>
</blockquote>
<pre><code class="language-javascript">var p1 = new Promise(function (resolve, reject) {
  resolve('成功');
});
p1.then(console.log, console.error);
// &quot;成功&quot;

var p2 = new Promise(function (resolve, reject) {
  reject(new Error('失败'));
});
p2.then(console.log, console.error);
// Error: 失败
</code></pre>
<p><strong>.then()方法可以链式使用</strong></p>
<pre><code class="language-javascript"> p1
  .then(step1) // step都是回调函数
  .then(step2)
  .then(step3) // step3是函数有返回值，后一个then的log可以显示
  .then(
    console.log,
    console.error
  );
</code></pre>
<p>p1后面有四个then方法，即有四个回调函数，只要上一步为resolved就会依次执行后面的回调函数。</p>
<p>最后一个then方法，log只显示step3的返回值；<strong>error可以显示step1、step2、step3任意一个的错误</strong>。eg.如果<code>step1</code>的状态变为<code>rejected</code>，那么<code>step2</code>和<code>step3</code>都不会执行了。</p>
<blockquote>
<p>Promise对象的报错具有传递性</p>
</blockquote>
<p><strong>Note：简单来说：then()方法用来添加回调函数</strong></p>
<hr>
<h4 id="35-微任务">3.5 微任务</h4>
<p>Promise的回调函数不是正常的异步任务，而是微任务（microtask）</p>
<p>微任务和正常异步任务之间的区别：</p>
<ul>
<li>正常异步任务追加到下一轮事件循环</li>
<li>微任务（另外一种异步任务）追加到本轮事件循环</li>
<li>即：微任务的执行时间一定早于正常异步任务</li>
</ul>
<pre><code class="language-javascript">setTimeout(function() {
  console.log(1);
}, 0);

new Promise(function (resolve, reject) {
  resolve(2);
}).then(console.log);

console.log(3);
// 3
// 2
// 1
</code></pre>
<hr>
<h4 id="36-总结">3.6 总结</h4>
<p>Promise让回调函数变成了链式写法。可以同时执行多个异步操作，等它们状态都改变以后，再执行一个回调函数。</p>
<blockquote>
<p>Promise状态一旦改变，无论何时都可以看到这个状态。所以，可以随便什么时候都可以为Promise对象实例通过then方法添加回调函数，且都能执行。</p>
</blockquote>
<p><strong>即：Promise指定回调函数的方式更加灵活</strong></p>
<p>指定回调函数方式：</p>
<ul>
<li>纯回调函数方式
<ul>
<li>必须在异步任务之前指定回调函数（异步任务开始之前传入成功和失败的回调函数）</li>
</ul>
</li>
<li>Promise方式
<ul>
<li>可以在异步任务之前和之后指定回调函数（可以在请求发出甚至结束之后指定回调函数）</li>
<li>启动异步任务 =&gt; 返回Promise对象 =&gt; promise对象绑定回调函数(甚至<strong>可以在异步任务结束后指定</strong>）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="四-promise对象总体介绍">四、Promise对象总体介绍</h3>
<h4 id="41-promise含义">4.1 Promise含义</h4>
<p>Promise是一种异步编程的解决方案，传统的异步编程解决方案是：回调函数和事件。</p>
<p>Promise是一个容器，里面保存一个异步操作的结果；Promise也是一个对象，从Promise可以获得异步操作的消息。</p>
<blockquote>
<p>Promise可以将异步操作以同步操作的流程表达出来，避免层层嵌套。</p>
</blockquote>
<p>Promise对象的特点：</p>
<ul>
<li>Promise对象状态只取决于异步操作的结果，不受外界影响。</li>
<li>Promise对象状态一旦改变，就不会再变化，且任何时候都可以得到这个结果；事件Event不同，一旦错过，再去监听也得不到结果。</li>
</ul>
<hr>
<h4 id="42-基本用法">4.2 基本用法</h4>
<pre><code class="language-javascript">const promise = new Promise(function(resolve, reject) {
  // ... some code
  
  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});

promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
</code></pre>
<p><strong>Promise实例对象生成后可以通过then()方法指定resolved状态和rejected状态的回调函数</strong></p>
<p>then()方法接受两个参数，且这两个参数都是回调函数形式，都接受Promise对象传出的值作为参数。</p>
<pre><code class="language-javascript">let promise = new Promise(function(resolve, reject) {
  console.log('Promise');
  resolve();
});

promise.then(function() {
  console.log('resolved.');
});

console.log('Hi!');

// Promise
// Hi!
// resolved
</code></pre>
<p>Promise新建后就会立即执行，即，Promise参数的执行器函数是一个同步回调，里面不是异步的代码都会立即执行。</p>
<pre><code class="language-javascript">const p1 = new Promise(function (resolve, reject) {
  // ...
});

const p2 = new Promise(function (resolve, reject) {
  // ...
  resolve(p1);
})
</code></pre>
<p>p2的resolve方法将p1作为参数，即p2异步操作的结果是返回p1的异步操作。</p>
<p>此时，p1的状态会传递给p2，即p1的状态决定了p2的状态。</p>
<blockquote>
<p>例子：</p>
</blockquote>
<pre><code class="language-javascript">const p1 = new Promise(function (resolve, reject) {
  setTimeout(() =&gt; reject(new Error('fail')), 3000)
})

const p2 = new Promise(function (resolve, reject) {
  setTimeout(() =&gt; resolve(p1), 1000)
})

p2
  .then(result =&gt; console.log(result))
  .catch(error =&gt; console.log(error))
// Error: fail
</code></pre>
<blockquote>
<p>p1三秒变为rejected状态，p2一秒后改变状态，resolve方法返回p1，此时p2自己状态无效，返回了另一个Promise对象的状态即p1状态。</p>
<p>此时针对p2的then方法，实质就是针对p1的then方法。</p>
</blockquote>
<p><strong>一般而言resolve()和rejected()方法都写在执行器函数的代码段最后，且在这两个函数之前加上return，保证执行器后面的代码不执行</strong></p>
<hr>
<h4 id="43-then方法">4.3 then()方法</h4>
<p>then()为Promise实例对象指定状态改变后的回调函数。</p>
<blockquote>
<p>重点：then()方法返回的是一个<strong>新的Promise实例</strong>（不是原来的Promise实例），所以then()可以采用链式写法，调用另一个then方法；同理，catch()方法返回的也是一个<strong>新的Promise实例</strong></p>
</blockquote>
<pre><code class="language-javascript">getJSON(&quot;/post/1.json&quot;)
.then(
  post =&gt; getJSON(post.commentURL) // getJSON返回一个新的Promise对象
).then(
  comments =&gt; console.log(&quot;resolved: &quot;, comments),
  err =&gt; console.log(&quot;rejected: &quot;, err)
);
</code></pre>
<p>该代码指定了两个回调函数，第一个then回调函数完成后，将返回结果作为参数，传入第二个then回调函数。第二个then回调函数，会等待新的Promise对象状态发生改变，如果状态变为resolved，就调用第一个回调函数，如果状态变为rejected，就调用第二个回调函数。</p>
<hr>
<h4 id="44-catch方法">4.4 catch()方法</h4>
<p>catch（）用来指定发生错误的回调函数，catch()返回的还是一个新的Promise对象</p>
<p><code>Promise.prototype.catch() === .then(null, reject) === .then(undefined, reject)</code></p>
<pre><code class="language-javascript">p.then((val) =&gt; console.log('fulfilled:', val))
  .catch((err) =&gt; console.log('rejected', err));

// 等同于
p.then((val) =&gt; console.log('fulfilled:', val))
  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));
</code></pre>
<p>捕获错误与抛出错误</p>
<pre><code class="language-javascript">// 写法一
const promise = new Promise(function(resolve, reject) {
  try {
    throw new Error('test');
  } catch(e) {
    reject(e);
  }
});
promise.catch(function(error) {
  console.log(error);
});

// 写法二
const promise = new Promise(function(resolve, reject) {
  reject(new Error('test'));
});
promise.catch(function(error) {
  console.log(error);
});
</code></pre>
<p><strong>Promise对象执行器函数中只能返回一个resolve或者reject，如果有两个，则返回第一个出现的函数（因为Promise状态一旦改变，就不会再变）</strong></p>
<pre><code class="language-javascript">const promise = new Promise(function(resolve, reject) {  resolve('ok');  throw new Error('test'); // 后一个不执行，promise状态改变就不发生变化});promise  .then(function(value) { console.log(value) })  .catch(function(error) { console.log(error) });// ok
</code></pre>
<p><strong>Promise对象的错误具有“冒泡性质”，会一直往后传递，直到被then处理err(reason)捕获为止</strong></p>
<blockquote>
<p>不建议写then的第二个参数即err(reson)参数；建议使用catch()方法，来捕获错误处理的回调函数</p>
</blockquote>
<hr>
<h4 id="45-finally方法">4.5 finally()方法</h4>
<p>finally()用来指定不管Promise对象最后状态如何，都会执行的操作。</p>
<pre><code class="language-javascript">promise.then(result =&gt; {···}).catch(error =&gt; {···}).finally(() =&gt; {···});server.listen(port)  .then(function () {    // ...  })  .finally(server.stop);
</code></pre>
<p>finally()方法不关心调用finally()的Promise实例状态，不依赖于Promise执行的结果。</p>
<hr>
<h4 id="46-all方法">4.6 all()方法</h4>
<p>all()将多个Promise实例，包装成一个新的Promise实例</p>
<pre><code class="language-javascript">const p = Promise.all([p1, p2, p3]);
</code></pre>
<p>特点：</p>
<ul>
<li>p1 p2 p3都为resolved，p的状态才是resolved。此时，p1 p2 p3 返回值组成一个数组，传递给p的回调函数。</li>
<li>p1 p2 p3有一个为rejected，p的状态就为rejected。此时，第一个被rejected的实例返回值，会传递给p的回调函数。</li>
</ul>
<pre><code class="language-javascript">const p1 = new Promise((resolve, reject) =&gt; {  resolve('hello');}).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; {  throw new Error('报错了');}).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]) // 此时p2执行上述代码的then方法.then(result =&gt; console.log(result)) // 调用这个回调函数.catch(e =&gt; console.log(e));// [&quot;hello&quot;, Error: 报错了]
</code></pre>
<p>上述代码解读：p1首先变为resolved，p2先变为rejected，但p2有自己的catch方法，该方法返回一个新的Promise实例对象，all函数中的p2Promise实例对象，其实是这个Promise实例对象。导致，all方法参数里的两个Promise实例对象都是resolved状态。</p>
<blockquote>
<p><strong>重点：如果一个promise中有reject()，但是其对应的回调函数then方法中有对应解决的reason，则该then返回新的Promise对象状态由回调函数执行结果return来决定</strong></p>
</blockquote>
<pre><code class="language-javascript">const p1 = new Promise((resolve, reject) =&gt; {  resolve('hello');}).then(result =&gt; result);const p2 = new Promise((resolve, reject) =&gt; {  throw new Error('报错了');}).then(result =&gt; result);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// Error: 报错了
</code></pre>
<p>上述代码解读：由于p2没有catch方法，就会调用all当中的catch方法</p>
<hr>
<h4 id="47-race方法">4.7 race()方法</h4>
<p>race() 英文有“比赛”意思。也是将多个Promise实例对象，包装成一个新的Promise实例对象，其中新的Promise实例对象状态和最先完成的子Promise实例对象有关。</p>
<pre><code class="language-javascript">const p = Promise.race([p1, p2, p3]);
</code></pre>
<p>其中，<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<hr>
<h4 id="48-resolve方法">4.8 resolve()方法</h4>
<p>Promise.resolve()方法返回一个新的Promise实例对象，将现有对象转为Promise对象。</p>
<pre><code class="language-javascript">Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo'))
</code></pre>
<hr>
<h4 id="49-reject方法">4.9 reject()方法</h4>
<p>Promise.reject()方法返回一个新的Promise实例对象，该实例状态为rejected</p>
<pre><code class="language-javascript">const p = Promise.reject('出错了');// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) {  console.log(s)});// 出错了
</code></pre>
<hr>
<h4 id="410-promise关键点">4.10 Promise关键点</h4>
<ol>
<li>
<p>如何改变Promise对象的状态：</p>
<ul>
<li>resolve(value) 当前pending状态变为resolved状态</li>
<li>reject(reason) 当前pending状态变为rejected状态</li>
<li>throw new Error('xxx') 抛出异常，当前pending状态变为rejected状态</li>
</ul>
</li>
<li>
<p>一个Promise对象可以指定多个回调函数，并都会调用</p>
</li>
</ol>
<pre><code class="language-javascript">const p = new Promise((resolve, reject) =&gt; {  resolve(1)})p.then(    value =&gt; {      console.log('value1', value)    })p.then(    value =&gt; {      console.log('value2', value)    })// value1 1// value2 1
</code></pre>
<ol start="3">
<li>
<p>改变Promise状态和指定回调函数谁先谁后的问题</p>
<blockquote>
<p>指定回调函数指的是，调用then()方法</p>
</blockquote>
<ul>
<li>都有可能，正常情况下，是先指定回调函数，再改变Promise状态（纯回调函数先指定回调函数）；但也可以先Promise改变状态，再指定回调函数</li>
<li>如何先改变状态再指定回调函数？
<ul>
<li>在Promise的执行器函数中直接调用resolve() / reject()，执行器函数中没有异步代码</li>
<li>延长更长的时间才调用then()</li>
</ul>
</li>
<li>什么时候得到数据？
<ul>
<li>如果先指定回调，当状态改变时，回调函数就会调用，得到数据</li>
<li>如果先改变状态，当指定回调时，回调函数就会直接调用，得到数据</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果执行器函数有异步回调，则先指定回调函数（then），后改变状态；</p>
<p>如果执行器函数中没有异步回调，则先改变状态，再通过then指定回调函数，并立即执行</p>
</blockquote>
</li>
<li>
<p>promise.then()返回的新promise实例对象的结果状态由什么决定？【重要】</p>
<ul>
<li>简单来说：由then指定回调函数执行的结果决定</li>
<li>复杂来说：
<ul>
<li>如果then()回调函数抛出异常，则新promise实例对象状态为rejected，reason为抛出异常</li>
<li>如果then()回调函数返回的是非promise对象的任意指，例如，return 3 / return undefined；则新Promise实例对象状态为resolved，value为回调函数返回值</li>
<li>如果then()回调函数返回的是一个新的Promise对象，则此Promise对象的结果为then回调函数后生成新的Promise对象的值 return Promise.resolve(3)</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">new Promise((resolve, reject) =&gt; {  reject(1)}).then(    value =&gt; {      console.log('onResolved1()', value)      // return 1    },    reason =&gt; {      console.log('onRejected1()', reason)      return Promise.resolve(2)      // return Promise.reject(2)    }).then(    value =&gt; {      console.log('onResolved2()', value)    },    reason =&gt; {      console.log('onRejected2()', reason)    })
</code></pre>
</li>
<li>
<p>Promise串联多个操作任务方法</p>
<ul>
<li>Promise的then方法返回一个新的Promise，可以当作then方法的链式调用</li>
<li>通过then链式调用串联多个同步 / 异步 任务</li>
</ul>
<pre><code class="language-javascript">new Promise((resolve, reject) =&gt; {  setTimeout(() =&gt; {    console.log(&quot;执行任务1(异步)&quot;)    resolve(1)  }, 1000);}).then(    value =&gt; {      console.log('任务1的结果: ', value)      console.log('执行任务2(同步)')      return 2    }).then(    value =&gt; {      console.log('任务2的结果:', value)      return new Promise((resolve, reject) =&gt; {        // 启动任务3(异步)        setTimeout(() =&gt; {          console.log('执行任务3(异步))')          resolve(3)        }, 1000);      })    }).then(    value =&gt; {      console.log('任务3的结果: ', value)    })
</code></pre>
</li>
<li>
<p>Promise的异常穿透</p>
<ul>
<li>
<p>当使用Promise的then链式调用，可以在最后指定失败的回调</p>
</li>
<li>
<p>链式操作，前面的操作出现了异常，都可以穿到最后失败的回调函数处</p>
</li>
<li>
<p><strong>Promise错误具有“冒泡性质”，会一直往后面传递，直至被then处理reason捕获为止</strong></p>
</li>
<li>
<blockquote>
<p>不建议写then的第二个参数即err(reson)参数；建议使用catch()方法，来捕获错误处理的回调函数</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>中断Promise链</p>
<ul>
<li>
<p>中断Promise链，意思是，在Promise的then链式调用中，在中间中断，不再调用后面的回调函数</p>
</li>
<li>
<p>方案：在某个then回调函数中返回一个pending状态的Promise对象</p>
<ul>
<li>
<pre><code class="language-javascript">return new Promise(() =&gt; {}) 
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="五-async和await使用">五、async和await使用</h3>
<h4 id="51-async">5.1 async</h4>
<p>async function用来定义一个异步函数（通过事件循环异步执行的函数）</p>
<p>async特点：</p>
<ul>
<li><strong>async函数的返回值是promise对象</strong>   return {promise}</li>
<li>async函数返回的promise对象结果值是由async函数执行的返回值决定</li>
</ul>
<pre><code class="language-javascript">async function fn1() {  return 1}const result1 = fn1()console.log(result1) // Promise { 1 }async function fn2() {  throw 2 // async返回一个失败的promise对象}const result2 = fn2()result2.catch(    reason =&gt; {      console.log(&quot;onRejected()&quot;, 2)    })// onRejected() 2
</code></pre>
<hr>
<h4 id="52-await">5.2 await</h4>
<p>await expression</p>
<p>expression表达式一般为promise对象，也可以是其他值</p>
<p>await特点：</p>
<ul>
<li>await 返回的是promise要处理的结果</li>
<li>如果表达式是promise对象，await返回的是【promise成功的值】</li>
<li>如果表达是其他值，直接将此值作为await的返回值</li>
</ul>
<p>await 作用：可以去掉then繁琐的操作</p>
<pre><code class="language-javascript">// 1. await得到成功的结果async function fn3() {  return Promise.resolve(3)}async function fn4() { // 使用await一定要用async函数  // const value = fn3()  // value.then(  //     value =&gt; {  //       console.log(value)  //     }  // )  const value = await fn3() // await 可以省去繁琐的then操作  console.log(value)}fn4()// 3// 2. await得到失败的结果async function fn5() {  return Promise.reject(4)}async function fn6() {  try {    const value = await fn5()    console.log(&quot;Value: &quot;, value)  } catch (e) {    console.log(&quot;Error: &quot;, e)  }}fn6()// Error:  4
</code></pre>
<hr>
<h3 id="六-宏队列和微队列">六、宏队列和微队列</h3>
<p>宏队列：</p>
<ul>
<li>用来保存待执行的宏任务(回调)， 比如: 定时器回调/DOM事件回调/ajax回调</li>
</ul>
<p>微队列：</p>
<ul>
<li>用来保存待执行的微任务(回调)， 比如: promise的回调/MutationObserver的回调</li>
</ul>
<p>JS引擎执行顺序：</p>
<ul>
<li>首先执行所有的同步任务代码</li>
<li>再执行微队列里的所有微任务</li>
<li>等微队列清空后，再去执行宏队列中的某个宏任务；如果某个宏任务里嵌套微任务，则把该微任务放入微队列，宏队列之后的宏任务要在该微任务之后执行。</li>
</ul>
<blockquote>
<p>关键点：执行宏队列中某个宏任务之前，需要清空微队列里的所有任务</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Binary Search Tree ]]></title>
        <id>https://lesenelir.github.io/post/binary-search-tree/</id>
        <link href="https://lesenelir.github.io/post/binary-search-tree/">
        </link>
        <updated>2020-07-12T02:10:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1二叉搜索树">1.二叉搜索树</h1>
<h3 id="概念">概念</h3>
<p>二叉搜索树：左子树结点值 &lt; 父结点值 &lt; 右子树结点值</p>
<blockquote>
<p>对于二叉搜索树来说，中序遍历能得到一个升序排列。</p>
</blockquote>
<h1 id="2二叉搜索树-插入">2.二叉搜索树---插入</h1>
<h3 id="二叉搜索树插入问题描述"><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_8_A">二叉搜索树插入问题描述</a></h3>
<h3 id="代码实现">代码实现</h3>
<pre><code class="language-C++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

struct Node {
	int key;
	Node *right, *left, *parent;	
};

Node *root, *NIL;

void insert(int k) {
	Node *y = NIL; // 前一个结点
	Node *x = root; // 当前结点
	Node *z; // 插入结点
	
	z = (Node *)malloc(sizeof(Node)); // 待插入结点一定是叶子结点
	z-&gt;key = k;
	z-&gt;left = NIL;
	z-&gt;right = NIL;
	
	while (x != NIL) {
		y = x;
		if (z-&gt;key &lt; x-&gt;key) {
			x = x-&gt;left;
		} else {
			x = x-&gt;right;
		}
	}
	z-&gt;parent = y;
	
	if (y == NIL) { //插入前的二叉树为空，z即为根结点
		root = z; 
	} else {
		if (z-&gt; key &lt; y-&gt;key) {
			y-&gt;left = z;
		} else {
			y-&gt;right = z;
		}
	}	
}

void inOrder(Node *u) {
	if (u == NIL) return;
	inOrder(u-&gt;left);
	printf(&quot; %d&quot;, u-&gt;key);
	inOrder(u-&gt;right);
}

void preOrder(Node *u) {
	if (u == NIL) return;
	printf(&quot; %d&quot;, u-&gt;key);
	preOrder(u-&gt;left);
	preOrder(u-&gt;right);
}


int main() {
	int n;
	while (scanf(&quot;%d&quot;, &amp;n) != EOF) {
		int x;
		string com;		
		for (int i = 0; i &lt; n; i++) {
			cin &gt;&gt; com;
			if (com == &quot;insert&quot;) {
				scanf(&quot;%d&quot;, &amp;x);
				insert(x);
			} else if (com == &quot;print&quot;) {
				inOrder(root);
				printf(&quot;\n&quot;);
				preOrder(root);
				printf(&quot;\n&quot;);
			}
		}		
	}
	return 0;
}
</code></pre>
<h3 id="算法解析">算法解析</h3>
<p>insert()函数以根结点为起点寻找结点z该插入的位置。<br>
当前结点x<br>
前一个结点y<br>
插入结点z</p>
<blockquote>
<p>二叉搜索树插入的结点一定是叶子结点。<br>
算法复杂度是O(logn)</p>
</blockquote>
<h1 id="3二叉搜索树-搜索">3.二叉搜索树---搜索</h1>
<h3 id="二叉搜索树搜索问题描述"><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_8_B">二叉搜索树搜索问题描述</a></h3>
<h3 id="代码实现-2">代码实现</h3>
<pre><code class="language-C++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

struct Node {
	int key;
	Node *left, *right, *parent;
};

Node *root, *NIL;

// 搜索算法
Node *find_key(Node *x, int k) {
	while ( x != NIL &amp;&amp; k != x-&gt;key) {
		if (k &lt; x-&gt;key) x = x-&gt;left;
		else x = x-&gt;right;
	}
	return x;
}

void insert(int k) {
	Node *y = NIL; // 前一个结点
	Node *x = root; // 当前结点
	Node *z; // 插入结点
	
	z = (Node *)malloc(sizeof(Node)); // 待插入结点一定是叶子结点
	z-&gt;key = k;
	z-&gt;left = NIL;
	z-&gt;right = NIL;
	
	while (x != NIL) {
		y = x;
		if (z-&gt;key &lt; x-&gt;key) {
			x = x-&gt;left;
		} else {
			x = x-&gt;right;
		}
	}
	z-&gt;parent = y;
	
	if (y == NIL) { //插入前的二叉树为空，z即为根结点
		root = z; 
	} else {
		if (z-&gt; key &lt; y-&gt;key) {
			y-&gt;left = z;
		} else {
			y-&gt;right = z;
		}
	}	
}

void inOrder(Node *u) {
	if (u == NIL) return;
	inOrder(u-&gt;left);
	printf(&quot; %d&quot;, u-&gt;key);
	inOrder(u-&gt;right);
}

void preOrder(Node *u) {
	if (u == NIL) return;
	printf(&quot; %d&quot;, u-&gt;key);
	preOrder(u-&gt;left);
	preOrder(u-&gt;right);
}

int main() {
	int n;
	while (scanf(&quot;%d&quot;, &amp;n) != EOF) {
		int x;
		string com;
		for (int i = 0; i &lt; n; i++) {
			cin &gt;&gt; com;
			if (com == &quot;find&quot;) {
				scanf(&quot;%d&quot;, &amp;x);
				Node *temp = find_key(root, x);
				if (temp != NIL) printf(&quot;YES\n&quot;);
				else printf(&quot;NO\n&quot;);
			} else if (com == &quot;insert&quot;) {
				scanf(&quot;%d&quot;, &amp;x);
				insert(x);
			} else if (com == &quot;print&quot;) {
				inOrder(root);
				printf(&quot;\n&quot;);
				preOrder(root);
				printf(&quot;\n&quot;);
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="算法解析-2">算法解析</h3>
<p>Node *find_key(Node *x, int k) 以根结点为起点调用函数，从根结点向叶结点搜索。<br>
给定键值小于当前结点x的键值，则左移；给定键值大于当前结点x的键值，则右移。<br>
键值不存在则返回NIL。</p>
<blockquote>
<p>假设树高为h，则find算法复杂度为O(h)</p>
</blockquote>
<h1 id="4二叉搜索树-删除">4.二叉搜索树---删除</h1>
<h3 id="二叉搜索树搜索问题描述-2"><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_8_C">二叉搜索树搜索问题描述</a></h3>
<h3 id="代码实现-3">代码实现</h3>
<pre><code class="language-C++">// 树的最小值
Node *treeMinimum(Node * x) {
    while (x-&gt;left != NIL) {
        x = x-&gt;left;
    }
    return x;
}

// case 3 ,搜索后一个结点
Node *treeSuccessor(Node *x) {
    if (x-&gt;right != NIL)
        return treeMinimum(x-&gt;right);

    Node *y = x-&gt;parent;
    while (y != NIL &amp;&amp; x == y-&gt;right) {
        x = y;
        x = y-&gt;parent;
    }
    return y;
}

void treeDelete(Node * z) {
    Node *y, *x;  // 要删除的对象和y的子结点

    // 确定要删除的结点
    if (z-&gt;left == NIL || z-&gt;right == NIL) y = z;
    else {
        y = treeSuccessor(z);
    }

    // 确定y的子结点x
    if (y-&gt;left != NIL) x = y-&gt;left;
    else x = y-&gt;right;

    // 让子结点链接父结点
    if (x != NIL) x-&gt;parent = y-&gt;parent;

    // 让父结点链接子结点
    if (y-&gt;parent == NIL) root = x;
    else {
        if (y == y-&gt;parent-&gt;left)
            y-&gt;parent-&gt;left = x;
        else
            y-&gt;parent-&gt;right = x;
    }

    // case 3
    if (y != z) z-&gt;key = y-&gt;key;
    delete y;
}
</code></pre>
<h3 id="算法解析-3">算法解析</h3>
<p>删除功能需要考虑三种情况，假设删除的结点为x<br>
（1）x没有子结点，则将x结点删除即可。<br>
（2）如果x只有左子树或者只有右子树，则将子树拼接上父结点即可.<br>
（3）如果同时具有左右子树。可以将结点x的左子树的最大值（也就是左子树一直往右孩子节点遍历即是最大值）或者右子树的最小值（也就是右子树一直往左孩子节点遍历即是最小值）替换x，然后拼接左子树或者右子树</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tree Algorithm]]></title>
        <id>https://lesenelir.github.io/post/tree-algorithm/</id>
        <link href="https://lesenelir.github.io/post/tree-algorithm/">
        </link>
        <updated>2020-07-11T03:30:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1有根树的表达">1.有根树的表达</h1>
<h3 id="概念">概念</h3>
<p>结点深度：根结点到结点x的路径长度称为结点x的深度。<br>
结点高度：结点x到叶结点最大路径长度称为结点x的高。<br>
树高：从根结点到叶子结点最大路径长度。<br>
结点的度：结点x的子结点的数目。</p>
<h3 id="有根树表达问题描述"><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_7_A">有根树表达问题描述</a></h3>
<h3 id="代码实现">代码实现</h3>
<pre><code class="language-C++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

const int maxn = 100001;
const int NIL = -1;


struct Node {
	int p, l, r;
} T[maxn];

int n;
int D[maxn]; // 深度数组

void print(int u) {
	printf(&quot;node %d: parent = %d, depth = %d, &quot;, u, T[u].p, D[u]);
	
	if (T[u].p == NIL) printf(&quot;root, &quot;);
	else if (T[u].l == NIL) printf(&quot;leaf, &quot;); // 不存在最左侧的结点
	else printf(&quot;internal node, &quot;);
	
	printf(&quot;[&quot;);
	for (int i = 0, c = T[u].l; c != NIL; i++, c = T[c].r) {
		if (i) printf(&quot;, &quot;);
		printf(&quot;%d&quot;, c);
	}
	printf(&quot;]\n&quot;);
}

// 递归求深度，保存在D数组中
int setDepth(int u, int p) {
	D[u] = p;
	if (T[u].r != NIL) setDepth(T[u].r, p); // 右侧兄弟设置相同深度
	if (T[u].l != NIL) setDepth(T[u].l, p + 1); // 左侧子结点深度设置为自己深度+1
}

int main() {
	int n;
	while (scanf(&quot;%d&quot;, &amp;n) != EOF) {
		for (int i = 0; i &lt; n; i++) {
			T[i].p = T[i].l = T[i].r = NIL;
		}
		int v, d, c, l, r;
		for (int i = 0; i &lt; n; i++) {
			scanf(&quot;%d %d&quot;, &amp;v, &amp;d);
			for (int j = 0; j &lt; d; j++) {
				scanf(&quot;%d&quot;, &amp;c);
				if (j == 0) T[v].l = c; // j==0叶子结点设置它的最左结点
				else T[l].r = c;
				l = c;
				T[c].p = v;
			}
		}
		for (int i = 0; i &lt; n; i++) {
			if (T[i].p == NIL) r = i;
		}
		
		setDepth(r, 0);
		for (int i = 0; i &lt; n; i++) {
			print(i);
		}
	}
	return 0;
}
</code></pre>
<h3 id="算法解析">算法解析</h3>
<ul>
<li>存储有根树 -----&gt; 左子右孩子表示法<br>
结点u的父节点<br>
结点u最左侧的子结点<br>
结点u右侧紧邻的兄弟结点<br>
此时，不存在u.l的就是叶子结点</li>
</ul>
<blockquote>
<p>假设树高为h，则从各结点出发求深度（寻找父结点）算法复杂度是O(n)，求所有结点的深度算法复杂度是O(nh)</p>
</blockquote>
<h1 id="2二叉树的表达">2.二叉树的表达</h1>
<h3 id="概念-2">概念</h3>
<p>二叉树所有结点的度（结点子结点的个数）最多2，且二叉树严格区分左右子结点。</p>
<h3 id="二叉树表达问题描述"><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_7_B">二叉树表达问题描述</a></h3>
<h3 id="代码实现-2">代码实现</h3>
<pre><code class="language-C++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

const int maxn = 100001;
const int NIL = -1;

struct Node {
	int parent, left, right;
} T[maxn];

int n, D[maxn], H[maxn]; // 深度数组，高度数组

void setDepth(int u, int d) {
	if (u == NIL) return;
	D[u] = d;
	setDepth(T[u].left, d + 1);
	setDepth(T[u].right, d + 1);
}

int setHeight(int u) {
	int h1 = 0, h2 = 0;
	if (T[u].left != NIL) h1 = setHeight(T[u].left) + 1;
	if (T[u].right != NIL) h2 = setHeight(T[u].right) + 1;
	return H[u] = (h1 &gt; h2 ? h1 : h2);
}

// 返回结点u的兄弟结点
int getSibling(int u) {
	if (T[u].parent == NIL) return NIL;
	if (T[T[u].parent].left != u &amp;&amp; T[T[u].parent].left != NIL) 
		return T[T[u].parent].left;
	if (T[T[u].parent].right != u &amp;&amp; T[T[u].parent].right != NIL) 
		return T[T[u].parent].right;
	return NIL;
}


void print(int u) {
	printf(&quot;node %d: &quot;, u);
	printf(&quot;parent = %d, &quot;, T[u].parent);
	printf(&quot;sibling = %d, &quot;, getSibling(u));
	int deg = 0; // 度数
	if (T[u].left != NIL) deg++;
	if (T[u].right != NIL) deg++;
	printf(&quot;degree = %d, &quot;, deg);
	printf(&quot;depth = %d, &quot;, D[u]);
	printf(&quot;height = %d, &quot;, H[u]);
	
	if (T[u].parent == NIL) {
		printf(&quot;root\n&quot;);
	} else if (T[u].left == NIL &amp;&amp; T[u].right == NIL) {
		printf(&quot;leaf\n&quot;);
	} else {
		printf(&quot;internal node\n&quot;);
	}
}


int main() {
	while (scanf(&quot;%d&quot;, &amp;n) != EOF) {
		for (int i = 0; i &lt; n; i++) T[i].parent = NIL;
		
		int v, l, r, root = 0;
		for (int i = 0; i &lt; n; i++) {
			scanf(&quot;%d %d %d&quot;, &amp;v, &amp;l, &amp;r);
			T[v].left = l;
			T[v].right = r;
			if (l != NIL) T[l].parent = v;
			if (r != NIL) T[r].parent = v;
		}
		
		for (int i = 0; i &lt; n; i++) {
			if (T[i].parent == NIL) root = i;
		}	
		
		setDepth(root, 0);
		setHeight(root);
		
		for (int i = 0; i &lt; n; i++) {
			print(i);
		}
		
	}
	return 0;
}
</code></pre>
<h3 id="算法解析-2">算法解析</h3>
<p>计算结点高度（往下求最长路径），只需要计算出“左子结点高 + 1” 和 “右子结点高 + 1”，然后取最大值即可。</p>
<blockquote>
<p>求结点高度的算法复杂度是O(n)</p>
</blockquote>
<h1 id="3树的遍历">3.树的遍历</h1>
<h3 id="概念-3">概念</h3>
<ul>
<li>前序遍历：根结点-&gt;左子树-&gt;右子树</li>
<li>中序遍历：左子树-&gt;根结点-&gt;右子树</li>
<li>后序遍历：左子树-&gt;右子树-&gt;根结点</li>
</ul>
<h3 id="树的遍历问题描述"><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_7_B">树的遍历问题描述</a></h3>
<h3 id="代码实现-3">代码实现</h3>
<pre><code class="language-C++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

const int maxn = 100001;
const int NIL = -1;

struct Node {
	int p, l, r;
} T[maxn];

int n;


void preOrder(int u) {
	if (u == NIL) return;
	printf(&quot; %d&quot;, u);
	preOrder(T[u].l);
	preOrder(T[u].r);
}

void inOrder(int u) {
	if (u == NIL) return;
	inOrder(T[u].l);
	printf(&quot; %d&quot;, u);
	inOrder(T[u].r);
}

void postOrder(int u) {
	if (u == NIL) return;
	postOrder(T[u].l);
	postOrder(T[u].r);
	printf(&quot; %d&quot;, u);
}


int main() {
	int v, l, r, root;
	while (scanf(&quot;%d&quot;, &amp;n) != EOF) {
		for (int i = 0; i &lt; n; i++) { // 初始化
			T[i].p = NIL;
		}	
		
		for (int i = 0; i &lt; n; i++) {
			scanf(&quot;%d %d %d&quot;, &amp;v, &amp;l, &amp;r);
			T[v].l = l;
			T[v].r = r;
			if (l != NIL) T[l].p = v;
			if (r != NIL) T[r].p = v;
		}
		
		for (int i = 0; i &lt; n; i++) {
			if (T[i].p == NIL) root = i;
		}
		printf(&quot;PreOrder\n&quot;);
		preOrder(root);
		printf(&quot;\n&quot;);
		
		printf(&quot;InOrder\n&quot;);
		inOrder(root);
		printf(&quot;\n&quot;);
		
		printf(&quot;PostOrder\n&quot;);
		postOrder(root);
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="算法解析-3">算法解析</h3>
<blockquote>
<p>树的遍历会对每一个结点进行一次访问，故算法复杂度为O(n)。<br>
使用递归算法要注意，一旦树的结点数量庞大且分布不均，会导致递归深度过深。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Recursion & Divide and Conquer]]></title>
        <id>https://lesenelir.github.io/post/recursion-and-divide-and-conquer/</id>
        <link href="https://lesenelir.github.io/post/recursion-and-divide-and-conquer/">
        </link>
        <updated>2020-07-09T04:46:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1递归与分治">1.递归与分治</h1>
<h3 id="概述">概述</h3>
<p>分治法：通过求解局部性的小问题来解开原本的问题。<br>
分治步骤：</p>
<ol>
<li>将问题分割成局部问题</li>
<li>递归求解局部问题</li>
<li>将局部问题进行整合，解决原问题</li>
</ol>
<h1 id="2穷举搜索">2.穷举搜索</h1>
<h3 id="概述-2">概述</h3>
<p>对于穷举搜索来说，每一个元素都有选和不选两种选择</p>
<h3 id="线性搜索问题描述"><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_5_A">线性搜索问题描述</a></h3>
<h3 id="代码实现">代码实现</h3>
<pre><code class="language-C++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;


int n;
int A[50];

int solve(int i , int m) {
	if (m == 0) return 1;
	if (i &gt;- n) return 0;
	int res = solve(i + 1, m) || solve(i + 1, m - A[i]);
	return res;
}


int main() {
	int q, M;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;A[i]);
	}
	scanf(&quot;%d&quot;, &amp;q);
	for (int i = 0; i &lt; q; i++) {
		scanf(&quot;%d&quot;, &amp;M);
		if (solve(0, M) == 1) printf(&quot;YES\n&quot;);
		else printf(&quot;NO\n&quot;);
	}	
	return 0;
}
</code></pre>
<h3 id="算法解析">算法解析</h3>
<p>solve(int i, int m) 表示用第i个元素后面的元素能得到m时返回true。<br>
这样做的好处是，能够把solve(i, m)分解成solve(i+1, m)和solve(i+1, m-A[i])， m-A[i]表示使用了第i个元素。<br>
最后递归的原问题是solve(0, m)。</p>
<blockquote>
<p>递归会多次进行计算solve(i, m)，这样会有很多重复计算，我们通过动态规划可以解决这个问题。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Search Algorithm]]></title>
        <id>https://lesenelir.github.io/post/search-algorithm/</id>
        <link href="https://lesenelir.github.io/post/search-algorithm/">
        </link>
        <updated>2020-07-08T04:18:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1线性搜索">1.线性搜索</h1>
<h3 id="概述">概述</h3>
<p>从数组头开始顺次访问各元素，检查元素是否与目标值相等。</p>
<h3 id="线性搜索问题描述"><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_4_A">线性搜索问题描述</a></h3>
<h3 id="代码实现">代码实现</h3>
<pre><code class="language-C++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

const int maxn = 10010;
int S[maxn];
int T[maxn];

bool lineSearch(int S[], int n, int key) {
	bool flag = false;
	for (int i = 0; i &lt; n; i++) {
		if (S[i] == key) {
			flag = true;
			break;
		}
	}
	return flag;
}

int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;S[i]);
	}
	int q;
	scanf(&quot;%d&quot;, &amp;q);
	for (int i = 0; i &lt; q; i++) {
		scanf(&quot;%d&quot;, &amp;T[i]);
	}
	int count = 0;
	for (int i = 0; i &lt; q; i++) {
		if (lineSearch(S, n, T[i]) == true) count++;
	}
	printf(&quot;%d\n&quot;, count);
	return 0;
}
</code></pre>
<h3 id="算法解析">算法解析</h3>
<p>ineSearch()函数是查询数组S中是否含有key的值。</p>
<blockquote>
<p>线性搜索一般来说都是用for循环来处理，算法复杂度为O(n)</p>
</blockquote>
<h1 id="2二分搜索">2.二分搜索</h1>
<h3 id="概述-2">概述</h3>
<p>二分搜索首先针对的是有序的序列，其次是检索范围正中央的元素，最后看关键字位于正中央元素的哪侧。</p>
<h3 id="二分搜索问题描述"><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_4_B">二分搜索问题描述</a></h3>
<h3 id="代码实现-2">代码实现</h3>
<pre><code class="language-C++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

const int maxn = 100010;
int S[maxn];
int T[maxn];
int n;

int binarySearch(int key) {
	int left = 0;
	int right = n;
	int mid;
	while (left &lt; right) {
		mid = (left + right) / 2;
		if (key == S[mid]) return 1;
		if (key &gt; S[mid]) left = mid + 1;
		else if (key &lt; S[mid]) right = mid;
	}
	return 0;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;S[i]);
	}
	int q;
	scanf(&quot;%d&quot;, &amp;q);
	for (int i = 0; i &lt; q; i++) {
		scanf(&quot;%d&quot;, &amp;T[i]);
	}
	int count = 0;
	for (int i = 0; i &lt; q; i++) {
		if (binarySearch(T[i]) == 1) count++;
	}
	printf(&quot;%d\n&quot;, count);
	return 0;
}
</code></pre>
<h3 id="算法解析-2">算法解析</h3>
<p>binarySearch()是二分搜索的模版</p>
<blockquote>
<p>对于搜索查找问题，都可以使用二分搜索算法来解决。<br>
但使用二分查找时，需要对数据进行排序，一般来说进行初等排序算法来解决。若要考虑数据体积，则需要用高等排序算法。<br>
二分搜索算法的算法复杂度为O(logn)</p>
</blockquote>
<h1 id="3散列法">3.散列法</h1>
<h3 id="概述-3">概述</h3>
<p>各元素的存储保存在散列表中，元素的存储位置由散列函数决定，只需把元素的关键值代入特定的函数就可以找出对应的位置。</p>
<h3 id="散列法问题描述"><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_4_C">散列法问题描述</a></h3>
<pre><code class="language-C++">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;

#define M 1046527
#define NLL (-1)
#define L 14
#define ll long long int

char H[M][L];

//char 转 int
int getChar(char ch) {
	if (ch == 'A') return 1;
	else if (ch == 'C') return 2;
	else if (ch == 'G') return 3;
	else if (ch == 'T') return 4;
	else return 0;
}

//str 转int 并生成 key
ll getKey(char str[]) {
	ll sum = 0, p = 1,i;
	for(i = 0; i &lt; strlen(str); i++) {
		sum += p * (getChar(str[i]));
		p *= 5;
	}
	return sum;
}

int h1(int key) { return key % M; }
int h2(int key) { return 1 + (key % (M-1));}

int Find(char str[]) {
	ll key,i,h;
	key = getKey(str);
	for (i = 0; ; i++) {
		h = (h1(key) + i * h2(key)) % M;
		if (strcmp(H[h], str) == 0) return 1;
		else if (strlen(H[h]) == 0) return 0;
	}
	return 0;
}

int Insert(char str[]) {
	ll key,i,h;
	key = getKey(str);
	for (i = 0; ; i++) {
		h = (h1(key) + i*h2(key)) % M;
		if (strcmp(H[h], str) == 0) return 1;
		else if (strlen(H[h]) == 0) {
			strcpy(H[h],str);
			return 0;
		}
	}
	return 0;
}

int main() {
	int i,n,h;
	char str[L],com[9];
	for (i = 0; i &lt; M; i++) {
		H[i][0]= '\0';
	}
	scanf(&quot;%d&quot;,&amp;n);
	for (i = 0; i &lt; n; i++) {
		scanf(&quot;%s %s&quot;, com, str);
		if (com[0] == 'i') {
			Insert(str);
		} else {
			if (Find(str)) {
				printf(&quot;yes\n&quot;);
			} else printf(&quot;no\n&quot;);
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Basic Sorting Algorithm]]></title>
        <id>https://lesenelir.github.io/post/basic-sorting-algorithm/</id>
        <link href="https://lesenelir.github.io/post/basic-sorting-algorithm/">
        </link>
        <updated>2020-07-03T09:15:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1初等排序">1.初等排序</h1>
<h3 id="概述">概述</h3>
<p>一般来说数据都是一张具有多个属性的表，所谓的排序就是以按照某种特定的属性为基准，这个特定属性就是排序键。</p>
<h3 id="准则">准则</h3>
<ul>
<li>复杂度</li>
<li>稳定性</li>
</ul>
<blockquote>
<p>所谓的稳定性是指：当有多个键值相等时，排序先后顺序按照输入的先后顺序。</p>
</blockquote>
<h1 id="2插入排序">2.插入排序</h1>
<h3 id="插入排序问题描述"><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_1_A">插入排序问题描述</a></h3>
<h3 id="代码实现">代码实现</h3>
<pre><code class="language-C++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

const int maxn = 10010;
int A[maxn];

void trace(int A[], int n) {
	for (int i = 0; i &lt; n; i++) {
		if (i &gt; 0) printf(&quot; &quot;);
		printf(&quot;%d&quot;, A[i]);
	}
	printf(&quot;\n&quot;);
}

void insertionSort(int A[], int n) {
	for (int i = 1; i &lt; n; i++) {
		int temp = A[i];
		int j = i - 1; // j从i往前枚举
		while (j &gt;= 0 &amp;&amp; A[j] &gt; temp) {
			A[j+1] = A[j];
			j--;
		}
		A[j+1] = temp;
		trace(A, n);
	}
}

int main() {
	int n;
	while (scanf(&quot;%d&quot;, &amp;n) != EOF) {
		for (int i = 0; i &lt; n; i++) {
			scanf(&quot;%d&quot;, &amp;A[i]);
		}	
		trace(A, n);
		insertionSort(A, n);
	}
	
	return 0;
}

</code></pre>
<h3 id="算法解析">算法解析</h3>
<p>外层循环i从1开始自增，每次循环的A[i]值保存在变量temp中。<br>
内存循环j从前往后枚举，找到比temp大的元素并依次后移，循环结束将temp插入j+1位置。</p>
<blockquote>
<p>插入排序不相邻的元素不会直接交换位置，所以插入排序是稳定排序。<br>
插入排序的算法复杂度是O(n^2).<br>
插入排序适用于相对有序的数据</p>
</blockquote>
<h1 id="3冒泡排序">3.冒泡排序</h1>
<h3 id="冒泡排序问题描述"><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_2_A">冒泡排序问题描述</a></h3>
<h3 id="代码实现-2">代码实现</h3>
<pre><code class="language-C++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

const int maxn = 10010;
int A[maxn];

int bubbleSort(int A[], int n) {
	int count = 0;
	bool flag = true;
	for (int i = 0; flag; i++) {
		flag = false;
		for (int j = n-1; j &gt;= i+1; j--) {
			if (A[j] &lt; A[j-1]) {
				swap(A[j], A[j-1]);
				flag = true;
				count++;
			}
		}
	}
	return count;
}


int main() {
	int n;
	while (scanf(&quot;%d&quot;, &amp;n) != EOF) {
		for (int i = 0; i &lt; n; i++) {
			scanf(&quot;%d&quot;, &amp;A[i]);
		}	
		int res = bubbleSort(A, n);
		for (int i = 0; i &lt; n; i++) {
			if (i &gt; 0) printf(&quot; &quot;);
			printf(&quot;%d&quot;, A[i]);
		}
		printf(&quot;\n&quot;);
		printf(&quot;%d\n&quot;, res);
	}
	return 0;
}
</code></pre>
<h3 id="算法解析-2">算法解析</h3>
<p>外层循环i表示未排序的开头元素，从开头向末尾移动。<br>
内存循环j表示相邻元素之间两两比较。</p>
<blockquote>
<p>冒泡排序是稳定的排序算法，但如果把条件判断改为A[j] &lt;= A[j-1]，则此时是不稳定算法。<br>
冒泡排序的算法复杂度是O(n^2).<br>
冒泡排序当中的交换次数又称为反序数或逆序数（线性代数），体现的是数组的错乱程度。</p>
</blockquote>
<h1 id="4选择排序">4.选择排序</h1>
<h3 id="选择排序问题描述"><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_2_B">选择排序问题描述</a></h3>
<h3 id="代码实现-3">代码实现</h3>
<pre><code class="language-C++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

const int maxn = 10010;
int A[maxn];

int selectSort(int A[], int n) {
	int count = 0;
	int temp;
	for (int i = 0; i &lt; n-1; i++) {
		int k = i;
		for (int j = i; j &lt; n; j++) {
			if (A[j] &lt; A[k]) {
				k = j;
			}
		}
		temp = A[i];
		A[i] = A[k];
		A[k] = temp;
		if (i != k) count++;
	}
	return count;
}



int main() {
	int n;
	while (scanf(&quot;%d&quot;, &amp;n) != EOF) {
		for (int i = 0; i &lt; n; i++) {
			scanf(&quot;%d&quot;, &amp;A[i]);
		}	
		int res = selectSort(A, n);
		for (int i = 0; i &lt; n; i++) {
			if (i &gt; 0) printf(&quot; &quot;);
			printf(&quot;%d&quot;, A[i]);
		}
		printf(&quot;\n&quot;);
		printf(&quot;%d\n&quot;, res);
		
	}
	return 0;
}
</code></pre>
<h3 id="算法解析-3">算法解析</h3>
<p>外层循环i遍历数组。<br>
内层循环j遍历从i开始的未排好序的序列，从这个序列中找出最小值，并交换元素。</p>
<blockquote>
<p>冒泡排序从局部入手减少逆序数，选择排序放眼大局逐个选择最小值。</p>
</blockquote>
]]></content>
    </entry>
</feed>